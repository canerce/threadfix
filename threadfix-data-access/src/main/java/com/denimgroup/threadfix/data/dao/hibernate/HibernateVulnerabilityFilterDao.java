////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2015 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.data.dao.hibernate;

import com.denimgroup.threadfix.data.dao.VulnerabilityFilterDao;
import com.denimgroup.threadfix.data.entities.*;
import org.hibernate.Criteria;
import org.hibernate.Query;
import org.hibernate.SessionFactory;
import org.hibernate.criterion.LogicalExpression;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

import static com.denimgroup.threadfix.CollectionUtils.list;

@Repository
public class HibernateVulnerabilityFilterDao implements VulnerabilityFilterDao {
	
	private SessionFactory sessionFactory;

	@Autowired
	public HibernateVulnerabilityFilterDao(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory; 
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAllGlobal() {
		return getBaseCriteria()
				.add(Restrictions.eq("global", true))
				.list();
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAll() {
		return getBaseCriteria().list();
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAll(int orgId) {
		return getBaseCriteria()
				.add(Restrictions.eq("organization.id", orgId))
				.list();
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAll(int orgId, int appId) {
		return getBaseCriteria()
				.add(Restrictions.eq("application.id", appId))
				.list();
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAllEffective(int orgId) {
		return getBaseCriteria()
				.add(Restrictions.disjunction()
						.add(Restrictions.eq("organization.id", orgId))
						.add(Restrictions.eq("global", true))
						)
				.list();
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAllEffective(int orgId, int appId) {
		return getBaseCriteria()
				.add(Restrictions.disjunction()
						.add(Restrictions.eq("application.id", appId))
						.add(Restrictions.eq("organization.id", orgId))
						.add(Restrictions.eq("global", true))
						)
				.list();
	}

	@Override
	public VulnerabilityFilter retrieveById(int vulnFilterId) {
		return (VulnerabilityFilter) getBaseCriteria()
				.add(Restrictions.eq("id", vulnFilterId))
				.uniqueResult();
	}

	@Override
	public VulnerabilityFilter retrieveByVulnerabilityAndType(
			int sourceGenericVulnerabilityId, VulnerabilityFilter filter) {
		
		VulnerabilityFilter returnFilter = null;
		if (filter != null) {
			Criteria criteria = getBaseCriteria()
					.add(Restrictions.eq("sourceGenericVulnerability.id", sourceGenericVulnerabilityId));
					
			if (filter.getOrganization() != null) {
				criteria.add(Restrictions.eq("organization.id", filter.getOrganization().getId()));
			} else if (filter.getApplication() != null) {
				criteria.add(Restrictions.eq("application.id", filter.getApplication().getId()));
			} else {
				criteria.add(Restrictions.eq("global", true));
			}
					
			returnFilter = (VulnerabilityFilter) criteria.uniqueResult();
		}
		
		return returnFilter;
	}

	private Criteria getBaseCriteria() {
		return sessionFactory.getCurrentSession()
				.createCriteria(VulnerabilityFilter.class)
				.add(Restrictions.eq("active", true));
	}

	@Override
	public void saveOrUpdate(VulnerabilityFilter vulnerabilityFilter) {
		if (vulnerabilityFilter != null && vulnerabilityFilter.getId() != null) {
			sessionFactory.getCurrentSession().merge(vulnerabilityFilter);
		} else {
			sessionFactory.getCurrentSession().saveOrUpdate(vulnerabilityFilter);
		}
	}
	
	@Override
	public void delete(int filterId) {
		VulnerabilityFilter filter = retrieveById(filterId);
		if (filter != null) {
			sessionFactory.getCurrentSession().delete(filter);
		}
	}

	@Override
	public void applyFilterToApplication(Integer applicationId, VulnerabilityFilter filter) {
		if (filter.getTargetGenericSeverity() == null) {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = true where vulnerability.genericVulnerability = :genericVulnerability and vulnerability.application.id = :application")
					.setParameter("application", applicationId)
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.executeUpdate();
		} else {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set genericSeverity = :genericSeverity where vulnerability.genericVulnerability = :genericVulnerability and vulnerability.application.id = :application")
					.setParameter("genericSeverity", filter.getTargetGenericSeverity())
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.setParameter("application", applicationId)
					.executeUpdate();
		}
	}

	@Override
	public void resetHiddenForApplication(Integer applicationId) {
		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = false where vulnerability.application.id = :application")
				.setParameter("application", applicationId)
				.executeUpdate();
	}

	@Override
	public void applySeverityFilterToApplication(Integer applicationId, SeverityFilter severityFilter) {
		hideSeverityApplication(applicationId, 5, severityFilter.getShowCritical());
		hideSeverityApplication(applicationId, 4, severityFilter.getShowHigh());
		hideSeverityApplication(applicationId, 3, severityFilter.getShowMedium());
		hideSeverityApplication(applicationId, 2, severityFilter.getShowLow());
		hideSeverityApplication(applicationId, 1, severityFilter.getShowInfo());
	}

	private void hideSeverityApplication(Integer applicationId, Integer intValue, boolean shouldShow) {

		List list = sessionFactory.getCurrentSession()
				.createQuery("select id from Vulnerability vulnerability where vulnerability.genericSeverity.intValue = :intValue and vulnerability.application.id = :application")
				.setParameter("intValue", intValue)
				.setParameter("application", applicationId)
				.list();

		if (!list.isEmpty()) {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = " + !shouldShow + " where id in (:vulnIds)")
					.setParameterList("vulnIds", list)
					.executeUpdate();
		}
	}

	@Override
	public void resetHiddenAll() {
		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = false")
				.executeUpdate();
	}

	@Override
	public void applySeverityFilterGlobal(SeverityFilter severityFilter) {
		if (!severityFilter.getShowCritical()) {
			hideSeverityGlobal(5);
		}
		if (!severityFilter.getShowHigh()) {
			hideSeverityGlobal(4);
		}
		if (!severityFilter.getShowMedium()) {
			hideSeverityGlobal(3);
		}
		if (!severityFilter.getShowLow()) {
			hideSeverityGlobal(2);
		}
		if (!severityFilter.getShowInfo()) {
			hideSeverityGlobal(1);
		}
	}

	private void hideSeverityGlobal(int intValue) {

		GenericSeverity severity = (GenericSeverity) sessionFactory.getCurrentSession()
				.createCriteria(GenericSeverity.class)
				.add(Restrictions.eq("intValue", intValue))
				.uniqueResult();

		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = true where vulnerability.genericSeverity = :severity")
				.setParameter("severity", severity)
				.executeUpdate();
	}

	@Override
	public void applySeverityFilterToTeam(Integer id, SeverityFilter severityFilter) {
		hideSeverityTeam(id, 5, severityFilter.getShowCritical());
		hideSeverityTeam(id, 4, severityFilter.getShowHigh());
		hideSeverityTeam(id, 3, severityFilter.getShowMedium());
		hideSeverityTeam(id, 2, severityFilter.getShowLow());
		hideSeverityTeam(id, 1, severityFilter.getShowInfo());
	}

	private void hideSeverityTeam(int teamId, int intValue, boolean shouldShow) {
		List list = sessionFactory.getCurrentSession().createQuery(
				"select id from Vulnerability vulnerability where vulnerability.application.id in (select id from Application where organization.id = :team) and vulnerability.genericSeverity.intValue = :intValue")
				.setParameter("intValue", intValue)
				.setParameter("team", teamId)
				.list();

		if (!list.isEmpty()) {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = " + !shouldShow + " where id in (:vulnIds)")
					.setParameterList("vulnIds", list)
					.executeUpdate();
		}
	}

	@Override
	public void applyFilterGlobal(VulnerabilityFilter filter) {
		if (filter.getTargetGenericSeverity() == null) {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = true where vulnerability.genericVulnerability = :genericVulnerability")
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.executeUpdate();
		} else {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set genericSeverity = :genericSeverity where vulnerability.genericVulnerability = :genericVulnerability")
					.setParameter("genericSeverity", filter.getTargetGenericSeverity())
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.executeUpdate();
		}
	}

	@Override
	public void applyFilterToTeam(Integer id, VulnerabilityFilter filter) {
		if (filter.getTargetGenericSeverity() == null) {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = true where vulnerability.genericVulnerability = :genericVulnerability and vulnerability.application in (select id from Application where organization.id = :teamId)")
					.setParameter("teamId", id)
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.executeUpdate();
		} else {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set genericSeverity = :genericSeverity where vulnerability.genericVulnerability = :genericVulnerability and vulnerability.application in (select id from Application where organization.id = :teamId)")
					.setParameter("genericSeverity", filter.getTargetGenericSeverity())
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.setParameter("teamId", id)
					.executeUpdate();
		}
	}

	@Override
	public List<Integer> getIgnoredIds(List<Integer> filteredSeverities, List<Integer> filteredVulnerabilities) {

		Criteria criteria = sessionFactory.getCurrentSession().createCriteria(Vulnerability.class)
				.setProjection(Projections.property("id"));

		if (!filteredSeverities.isEmpty() && !filteredVulnerabilities.isEmpty()) {
			criteria.createAlias("genericSeverity", "genericSeverityAlias");
			criteria.createAlias("genericVulnerability", "genericVulnerabilityAlias");

			LogicalExpression join = Restrictions.or(
					Restrictions.in("genericSeverityAlias.id", filteredSeverities),
					Restrictions.in("genericVulnerabilityAlias.id", filteredVulnerabilities));

			criteria.add(join);

		} else if (!filteredSeverities.isEmpty()) {
			criteria.createAlias("genericSeverity", "genericSeverityAlias");
			criteria.add(Restrictions.in("genericSeverityAlias.id", filteredSeverities));

		} else if (!filteredVulnerabilities.isEmpty()) {
			criteria.createAlias("genericVulnerability", "genericVulnerabilityAlias");
			criteria.add(Restrictions.in("genericVulnerabilityAlias.id", filteredVulnerabilities));
		} else {
			// if there are no filtered severities or types, return an empty list
			return list();
		}

		return criteria.list();
	}

	@Override
	public List<Map<String, Object>> getScanClosedVulnerabilitiesMap(List<Integer> ignoredVulnerabilityIds) {
		return runInnerMapQuery(ignoredVulnerabilityIds, ScanCloseVulnerabilityMap.class);
	}

	@Override
	public List<Map<String, Object>> getScanReopenedVulnerabilitiesMap(List<Integer> ignoredVulnerabilityIds) {
		return runInnerMapQuery(ignoredVulnerabilityIds, ScanReopenVulnerabilityMap.class);
	}

	private List<Map<String, Object>> runInnerMapQuery(List<Integer> ignoredVulnerabilityIds, Class<?> targetClass) {

		String className = targetClass.getName();

		String hql = "select new map (" +
				"count(*) as total, " +
				"closeMap.scan.id as scanId) " +
				"from " + className + " closeMap ";

		if (!ignoredVulnerabilityIds.isEmpty()) {
			hql += "where vulnerability.id not in (:vulnIds) ";
		}

		hql += "group by closeMap.scan.id";

		Query query = sessionFactory.getCurrentSession().createQuery(hql);

		if (!ignoredVulnerabilityIds.isEmpty()) {
			query.setParameterList("vulnIds", ignoredVulnerabilityIds);
		}

		Object idsMap = query.list();

		return (List<Map<String, Object>>) idsMap;
	}

	@Override
	public void hideForScanResultFilter(ScanResultFilter scanResultFilter) {
		assert scanResultFilter != null;
		assert scanResultFilter.getChannelType() != null;
		assert scanResultFilter.getGenericSeverity() != null;

		// get finding IDs first
		List result = sessionFactory.getCurrentSession().createCriteria(Finding.class)
				.createAlias("channelSeverity", "channelSeverityAlias")
				.createAlias("channelSeverityAlias.severityMap", "mapAlias")
				.createAlias("mapAlias.genericSeverity", "genericSeverityAlias")
				.createAlias("scan", "scanAlias")
				.createAlias("scanAlias.applicationChannel", "applicationChannelAlias")
				.createAlias("applicationChannelAlias.channelType", "channelTypeAlias")
				.add(Restrictions.eq("genericSeverityAlias.intValue", scanResultFilter.getGenericSeverity().getIntValue()))
				.add(Restrictions.eq("channelTypeAlias.id", scanResultFilter.getChannelType().getId()))
				.setProjection(Projections.property("id"))
				.list();

		if (result.isEmpty()) {
			return;
		}

		List toHide = sessionFactory.getCurrentSession().createCriteria(Vulnerability.class)
				.createAlias("findings", "findingsAlias")
				.add(Restrictions.in("findingsAlias.id", result))
				.setProjection(Projections.property("id"))
				.list();

		if (!toHide.isEmpty()) {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = true where vulnerability.id in (:toHide)")
					.setParameterList("toHide", toHide)
					.executeUpdate();
		}
	}

	@Override
	public VulnerabilityFilter find(GenericVulnerability sourceGenericVulnerability, int orgId, int appId) {
		Criteria criteria = sessionFactory
				.getCurrentSession()
				.createCriteria(VulnerabilityFilter.class)
				.createAlias("sourceGenericVulnerability", "genericAlias")
				.add(Restrictions.eq("genericAlias.id", sourceGenericVulnerability.getId()));

		if (orgId != -1) {
			criteria.createAlias("organization", "organizationAlias")
					.add(Restrictions.eq("organizationAlias.id", orgId));
		} else if (appId != -1) {
			criteria.createAlias("application", "applicationAlias")
					.add(Restrictions.eq("applicationAlias.id", appId));
		} else {
			criteria.add(Restrictions.eq("global", true));
		}


		List list = criteria.list();

		if (list.size() > 0) {
			return (VulnerabilityFilter) list.get(0);
		} else {
			return null;
		}
	}
}
